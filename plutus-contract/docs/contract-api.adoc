[#contract-api]
= Writing Plutus Contracts

The `PlutusContract` type represents the client-side parts of Plutus contracts. `PlutusContract` values describe the interactions of contracts with the blockchain and with the user. They can be composed in different ways, allowing you to assemble contracts from the building blocks provided by the Plutus library and by other contract authors.

When you have a `PlutusContract` you can compile it to a contract bundle (a format suitable for distributing contracts to end users).

== Simple contracts

[source,haskell]
----
module Tutorial.PlutusContract where
import           Language.Plutus.Contract
----

The type of a contract is `PlutusContract e a`. It has two type parameters: `e` describes the endpoints that the contract may use to get input from the end user, and `a` is the return type of the contract.

The simplest contract is the one that produces no transactions, and does not interact with the user or the wallet at all:

[source,haskell]
----
c1 :: PlutusContract e () -- <1>
c1 = return () -- <2>
----
<1> The type of `c1` is a Plutus contract that produces a unit value when it's finished. The fact that `e` is free tells us that `c1` does not use any endpoints.
<2> The implementation of `c1` returns the unit immediately.

=== Waiting

If we compiled `c1` and deployed it, it would finish right away without doing anything. To get the contract to interact with the environment we can use the functions exported by the `Language.Plutus.Contract` module. For example, `slotGeq {2c} Slot -> PlutusContract m Slot` is a function that takes a `Slot` argument and produces a contract that waits until the slot has been reached.

[source,haskell]
----
c2 :: PlutusContract e Slot
c2 = slotGeq 2765 -- <1>
----
<1> `c2` waits until slot 2765 before returning.

=== Blockchain Events

* We can use `nextTransactionAt {2c} Address -> PlutusContract e Tx` and `watchAddressUntil {2c} PlutusContract e AM.AddressMap` to watch out for blockchain events
* The `AddressMap` type contains a list of unspent outputs in a format that can be spent easily in a new transaction

TODO: Example

=== Transactions

Contracts write transactions using `writeTx {2c} UnbalancedTx -> PlutusContract e ()`. The transactions produced that way are unbalanced (as the name indicates) and unsigned. When executing a `writeTx` instruction, the app platform forwards the transaction to the user's wallet to balance it (by adding appropriate public key inputs or outputs) and compute the gas cost of any scripts involved. The finished transaction is then signed by the signing process, and submitted to the wallet which sends it to the blockchain.

TODO: Example

=== Endpoints

WARNING: This section is conceptual, the actual types may look different when it's implemented!

Many contracts require information from the end user. For example, if we send money somewhere then we need to know the amount and the address of the recipient. We might also want to inform the user that something has happened - that we sent the money, or how much time is left until we can unlock a value that is secured by a Plutus script.

Such interactions are realised using _endpoints_. You can think of endpoints as pieces of a user interface that display information and may take input in the form of text boxes, buttons, etc.

Let's say we write a contract that shows a `String` to the user, and expects an `Int` in return. 

[source,haskell]
----
c3 :: PlutusContract '[E String Int] Int -- <1>
c3 = endpoint "How much is the fish?" -- <2>
----
<1> Instead of the free `e` we now have a concrete type, namely an endpoint that expects an `Int` after showing a `String` to the user.
<2> When using `endpoint` we need to provide a value of `String`. This message will be shown to the user by the app platform.

NOTE: I think that in the initial implementation we will probably be limited to `E () a`, ie. endpoints that don't show anything to the user. Just getting the inputs `a` right in GraphQL will be tricky enough. Afterwards we can figure out how to represent the outputs in the schema.

Remember that the type variable `e` in `PlutusContract e a` describes the endpoints of the contract. For `c1` and `c2` we left `e` unspecified because those contracts did not have any user interactions. But now we need to commit to a specific type, namely `[E String Int]`. It's a list of possible endpoints, with a single element.

If we don't know what to write for `e`, we can also let the Haskell compiler tell us.

[source,haskell]
----
c4 :: PlutusContract _ Int -- <1>
c4 = endpoint "How much is the fish?"
----
<1> Note the underscore in place of the type argument. This is a type hole, and it will cause the compiler to emit a warning. This warning includes the inferred type, so we could copy and paste that into the the signature of `c4` if we wanted.

If we don't write out the type in the signature of `c4`, the compiler tries to infer it from the return type of the contract and from the argument to `endpoint`. Sometimes there are multiple candidate for `e`, and the compilation process fails. If that happens we can reduce the ambiguity by writing `c4 = endpoint @String @Int "How much is the fish?"` - using the `@` operator to put in the types.

NOTE: It's a list but it should really be a set!

By writing out the endpoints that our contracts have we ensure that our contracts are predictable - even if we don't know what a concrete instance of the contract will look like, we know for certain that it is never going to ask you for something that isn't specified in the type. 

== Combining contracts

Given two contracts we can combine them by running them in parallel, in sequence, or by selecting the one that finishes first.

Let's say we have two contracts `collect {2c} Contract e [TxIn]` and `recipient {2c} Contract '[E () PubKey] PubKey'`. `collect` watches the blockchain for payments to a script address, and after a while returns a list of inputs that spend all those payments. `recipient` asks the user for an address to make the payment to. Now we would like to build a contract that combines `collect` and `recipient` and then submits a transaction that spends all the inputs and pays the value to the given address.

=== Parallel

`collect` and `recipient` can run in parallel because neither of them depends on the other:

[source,haskell]
----
collectRec :: PlutusContract '[E () PubKey] ([TxIn], PubKey) -- <1>
collectRec = both collect recipient -- <2>
----
<1> `collectRec` is a contract that may use an endpoint asking for a public key. It returns two things: A list of transaction inputs and a public key.
<2> `collectRec` is implemented in terms of `collect` and `recipient`, using `both` to run both contracts at the same time.

NOTE: `both` is defined as `liftA2 (,)`: Parallel composition is using the applicative instance of `PlutusContract`

=== Sequential

After having obtained the inputs and the public key we can proceed to produce the transaction.

[source,haskell]
----
spend :: PlutusContract '[E () PubKey] ()
spend = do -- <1>
    (ins, pk) <- collectRec
    writeTx (mkTx ins pk)
----
<1> We use Haskell's do notation to signal the start of a sequence of actions

In the definition of `spend`, we run the `collectRec` contract from above and then pattern match on its result to get the `ins` and `pk` variables. After that we produce the transaction with `writeTx`.

NOTE: The monad instance of `PlutusContract` is used for sequential composition of contracts.

=== Select

What if a contract involves an alternative? Let's say we have a contract that represents a portfolio of stocks, and at any point in time the user can increase or decrease the number of shares. We represent those decisions with two types:

[source,haskell]
----
data Buy = Buy { symbol :: String, amount :: Int }
data Sell = Sell { symbol :: String, amount :: Int }
----

Then we define two contracts, `buy {2c} PlutusContract _ Buy` and `sell {2c} PlutusContract _ Sell`. Now the combined contract is

[source, haskell]
----
buyOrSell :: PlutusContract _ (Either Buy Sell)
buyOrSell = selectEither buy sell
----

The `selectEither` combinator takes two contracts with return types `a` and `b`, and produces a new contract with return type `Either a b` that produces the outcome of the branch that finished first.

NOTE: The `Alternative` instance of `PlutusContract` is used to select one of two branches.

=== Putting it all together

Let's look at a more complex example that shows how the three modes of composition can be combined:

[source, haskell]
----
newtype Portfolio = Portfolio (Map String Int)
emptyPortfolio :: Porfolio
addShares :: Buy -> Portfolio -> Portfolio
removeShares :: Sell -> Portfolio -> Portfolio

sharedealing :: PlutusContract _ ()
sharedealing = do
    initial <- buy
    let go pf = do
      decision <- buyOrSell
      let pf' = case decision of
                  Left b -> addShares b pf
                  Right s -> removeShares s pf
      go pf'
    go (addShares initial )
----

== Contract instances

Each `PlutusContract` describes a large set of possible paths that the contract can take. Each of those paths is an _instance_ of that contract. Instances are sequences of events that the contract reacts to, and the transactions it produces. For example, if you offer a loan to somebody in exchange for collateral, then that loan would be an instance of the `loan` contract.

Instances are client-specific. There is one instance of `loan` running on your machine, going through the lender branch, and another instance on the recipient's machine, following the borrower's side of the contract.

The app platform that executes contract bundle keeps track of the running instances.

== State

Conceptually the state of a contract instance is the sequence of events that it has seen so far. In reality we don't want to store all the events of the instance, because there might be many of them, and if we wanted to restore the state by replaying the events it would take longer and longer the more events there are.

To avoid keeping old events around for longer than necessary we can use the `jsonCheckpoint` function.


[source, haskell]
----
jsonCheckpoint :: (FromJSON a, ToJSON a) => PlutusContract e a -> PlutusContract e a
----

`jsonCheckpoint` is a unary operator that takes a `PlutusContract` with a result that can be written to and read from JSON. The bookeeping system that is used behind the scenes to keep track of contract state will, upon encountering a contract wrapped in `jsonCheckpoint`, run the contract once and then store the result of that contract as a JSON object. The next time we restore the contract's state, the system will _not_ replay the events for that contract, but instead use the `FromJSON` instance to restore the state.

NOTE: Contracts that don't use `jsonCheckpoint` are still able to have their state saved and restored. This will take the form of the `[Event]` sequence of inputs that have been seen so far. 

NOTE: To handle things like the loop in the `sharedealing` example we probably need something more explicit, like a notion of cells that can be written to and read from. But we could implement that in the same manner as the `jsonCheckpoint` (the important bit is how the JSON constraints are embedded in the contract definition)