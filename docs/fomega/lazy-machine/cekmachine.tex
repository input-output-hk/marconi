\begin{figure*}[!ht]
\caption{The CEK Machine}\label{fig:cek-machine}

\begin{subfigure}[c]{\linewidth}        %%% ---------------- CEK machine states ---------------- %%%
{\small
\caption{States}
\[
\begin{array}{lrcl}
        \textrm{Stack} & s      & ::= & f^*    \\
        \textrm{Environment} & \rho & ::= & [x \mapsto V]^* \\
        \textrm{State} & \sigma & ::= & s;\rho \compute M \quad | \quad s;\rho \return V  \quad | \quad \ckerror{} \quad | \quad \square V,\rho
    \end{array}
\]
}
\end{subfigure}

\vspace{3mm}
\hrule
\vspace{3mm}

\begin{subfigure}[c]{\linewidth}  %%% ---------------- CEK machine frames ---------------- %%%
{\small
\caption{Reduction frames}
\[
    \begin{array}{rlr}
       f ::= & \inInstLeftFrame{A}                     & \textrm{left instantiation}\\
             & \inWrapRightFrame{\alpha}{A}            & \textrm{right wrap}\\
             & \inUnwrapFrame{}                        & \textrm{unwrap}\\
             & \inAppLeftFrame{M}                      & \textrm{left application}\\
             & \inAppRightFrame{V}                     & \textrm{right application}\\
             & \inBuiltin{bn}{A^*}{V^*}{\_}{M^*}        & \textrm{builtin}\\
    \end{array}
\]
}
\end{subfigure}

\vspace{3mm}
\hrule
\vspace{3mm}

\begin{subfigure}[c]{\linewidth}  %%% ---------------- CEK machine transitions ---------------- %%%
{
\small
\caption{Transitions}
    \begin{alignat*}{2}
     \blue{s; \rho} &\bcompute \blue{x}          &{}\bmapsto{}&\blue{s;\rho \return V \quad (\rho[x] = V)}\\  % New rule
      s; \rho &\compute \con{cn}                 &{}\mapsto{}& s;\rho \return \con{cn}\\
      % computeCek con constant@Constant{}    = returnCek con constant
      s; \rho &\compute \abs{\alpha}{K}{V}       &{}\mapsto{}& s;\rho \return \abs{\alpha}{K}{V}\\
      % computeCek con tyAbs@TyAbs{}          = returnCek con tyAbs
      s; \rho &\compute \inst{M}{A}              &{}\mapsto{}& s,\inInstLeftFrame{A};\rho \compute M\\
      % ?? computeCek con (TyInst _ body ty)     = computeCek (FrameTyInstArg ty : con) body
      s; \rho &\compute \wrap{\alpha}{A}{M}      &{}\mapsto{}& s,\inWrapRightFrame{\alpha}{A};\rho  \compute M\\ 
      % ?? computeCek con (Wrap ann tyn ty term) = computeCek (FrameWrap ann tyn ty : con) term
      s; \rho &\compute \unwrap{M}               &{}\mapsto{}& s,\inUnwrapFrame{};\rho  \compute M\\
      %computeCek con (Unwrap _ term)        = computeCek (FrameUnwrap : con) term
      s; \rho &\compute \lam{x}{A}{M}            &{}\mapsto{}& s;\rho \return \lam{x}{A}{M}\\
      % computeCek con lamAbs@LamAbs{}        = returnCek con lamAbs
      s; \rho &\compute \app{M}{N}               &{}\mapsto{}& s,\inAppLeftFrame{N};\rho \compute M\\
      s; \rho &\compute \builtin{bn}{\repetition{A}}{} &{}\mapsto{}& U \quad (\textit{$bn$ computes on $\repetition{A}$ to $U$})\\
      s; \rho &\compute \builtin{bn}{\repetition{A}}{M \repetition{M}} &{}\mapsto{}& s;\rho \compute \inBuiltin{bn}{\repetition{A}}{}{\_}{\repetition{M}}{M}\\
      s; \rho &\compute \error{A} &{}\mapsto{}& \ckerror{}\\
      % computeCek _   Error{}                = pure EvaluationFailure
      \cdot; \rho &\return V &{}\mapsto{}& \square V, \rho\\
      s,\inInstLeftFrame{A}; \rho &\return \abs{\alpha}{K}{M} &{}\mapsto{}& s;\rho \compute{M} \\
      s,\inWrapRightFrame{\alpha}{A}; \rho &\return V &{}\mapsto{}& s;\rho \return \wrap{\alpha}{A}{V}\\
      s,\inUnwrapFrame{}; \rho &\return \wrap{\alpha}{A}{V} &{}\mapsto{}& s;\rho \return V\\
      s,\inAppLeftFrame{N}; \rho &\return V &{}\mapsto{}& s, \inAppRightFrame{V};\rho \compute N\\
      \blue{s,\inAppRightFrame{\lam{x}{A}{M}}; \rho} &\breturn V &{}\bmapsto{}& \blue{s;\rho[x\mapsto V] \compute M}\\  %% Modified
      s,\inBuiltin
      {bn}
      {\repetition{A}}
      {\repetition{V}}{\_}{}; \rho &\return V &{}\mapsto{}& U \quad (\textit{$bn$ computes on $\repetition{A}$ and $\repetition{V}V$ to $U$})\\
      s,  \inBuiltin{bn}{\repetition{A}}{\repetition{V}}{\_}{M \repetition{M}}{}; \rho&\return V &{}\mapsto{}& s, \inBuiltin{bn}{\repetition{A}}{\repetition{V} V}{\_}{\repetition{M}} \compute M\\
\end{alignat*}
}
\end{subfigure}
\end{figure*}


\begin{comment}
computeCek con (Apply _ fun arg)      = do
    varEnv <- getVarEnv
    computeCek (FrameApplyArg varEnv arg : con) fun
computeCek con (Var _ varName)        = do
computeCek con bi@Builtin{} = returnCek con bi

-- | The returning part of the CEK machine.
-- Returns 'EvaluationSuccess' in case the context is empty, otherwise pops up one frame
-- from the context and either
-- 1. performs reduction and calls 'computeCek' ('FrameTyInstArg', 'FrameApplyFun', 'FrameUnwrap')
-- 2. performs a constant application and calls 'returnCek' ('FrameTyInstArg', 'FrameApplyFun')
-- 3. puts 'FrameApplyFun' on top of the context and proceeds with the argument from 'FrameApplyArg'
-- 4. grows the resulting term ('FrameWrap')
returnCek :: Context -> Plain Value -> CekM EvaluationResult
returnCek []                                  res = pure $ EvaluationSuccess res
returnCek (FrameTyInstArg ty           : con) fun = instantiateEvaluate con ty fun
returnCek (FrameApplyArg argVarEnv arg : con) fun = do
    funVarEnv <- getVarEnv
    withVarEnv argVarEnv $ computeCek (FrameApplyFun funVarEnv fun : con) arg
returnCek (FrameApplyFun funVarEnv fun : con) arg = do
    argVarEnv <- getVarEnv
    applyEvaluate funVarEnv argVarEnv con fun arg
returnCek (FrameWrap ann tyn ty        : con) val = returnCek con $ Wrap ann tyn ty val
returnCek (FrameUnwrap                 : con) dat = case dat of
    Wrap _ _ _ term -> returnCek con term
    term            -> throwError $ MachineException NonWrapUnwrappedMachineError term

\end{comment}
