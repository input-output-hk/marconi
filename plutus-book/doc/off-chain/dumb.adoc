[source,haskell]
----
{-# LANGUAGE NoImplicitPrelude               #-}        -- <1>
{-# LANGUAGE TemplateHaskell                 #-}        -- <2>
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}        -- <3>

module Dumb where

import Language.PlutusTx.Prelude                        -- <4>
import Ledger
import Ledger.Ada
import Playground.Contract
import Wallet
import Wallet.Emulator.Types (walletPubKey)

myPayToWallet :: MonadWallet m => Wallet -> Ada -> m () -- <5>
myPayToWallet wallet ada = do
    let pubKey = walletPubKey wallet                    -- <6>
        val    = toValue ada
    payToPublicKey_ defaultSlotRange val pubKey

$(mkFunctions ['myPayToWallet])                         -- <7>
----

<1> Plutus comes with its own Prelude, so we disable implicit
import of the standard Haskell Prelude.

<2> Template Haskell is used for "lifting" Haskell types to
Plutus Core types, but also to make off-chain code available
in the Playground as in our example.

<3> The code generated by Plutus Template Haskell lacks type
signatures, so we disable the annoying warnings this would cause.

<4> We always import the Plutus Prelude.

<5> Function `myPayToWallet` takes two arguments,
the wallet to send funds to and the amount (in Ada) to send.
It works in any monad `m` which is an instance of the
`MonadWallet` class.
In particular, it will work just fine in the mock wallet
employed by the Playground.

<6> We can look up the public key belonging to a wallet with
`walletPubKey`.

<7> Using Template Haskell, `mkFunctions` will make all functions
named in its list of arguments usable in the Playground:
In our case, there will be a new "available function" in the "Simulation"-tab
with two arguments, corresponding to the two arguments of `myPayToWallet`.
